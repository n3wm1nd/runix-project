# Claude Code: Hidden Gems & Secret Sauce

> Engineering insights and non-obvious implementation details that make Claude Code work exceptionally well

---

## ðŸŽ¯ The Core Philosophy: Radical Simplicity

**"Every time there's a new model release, we delete a bunch of code."** - Boris Cherny

- With Claude 4.0, Anthropic **removed ~50% of their system prompt** because the improved model needed less scaffolding
- Treat the UI as "a lightweight shell on top of the Claude model"
- Constantly remove tools and system instructions - the model can do more than products enable
- **90% of Claude Code's codebase is generated by Claude Code itself**

### Key Insight
Don't over-engineer. Start minimal, add only what's necessary. The model will improve faster than your scaffolding code.

---

## ðŸ—ï¸ Architecture Patterns

### 1. **Three-Tier Hierarchical Structure**

```
Agent Loop (main conversation)
  â”œâ”€> Sub-Agents (isolated context windows for complex tasks)
  â”‚     â””â”€> Tool Calls (individual prompts per operation)
  â””â”€> BatchTool (parallel/serial execution)
```

**Why this matters:**
- Single-threaded execution on top of potentially chaotic multi-tasking
- Forces model to commit to sequential task completion
- Sub-agents reduce main conversation token overhead
- Isolated contexts prevent pollution

### 2. **Multi-Stage Processing Pipeline**

Every user input goes through:
1. **Topic Detection Layer** - Dedicated LLM call to classify if new thread or continuation
2. **Security Checks** - 6 orthogonal security validations (UI keystroke â†’ syscall)
3. **Command Analysis** - For bash:
   - Command prefix detection (what's running?)
   - File path extraction (what gets modified?)

**Why this matters:**
- Safety through layers, not single checks
- Explicit topic detection prevents context drift
- Two LLM calls per bash command (overhead but safe)

### 3. **Model Stratification**

Different models for different tasks:
- **Claude 3.7 Sonnet** - Reasoning-heavy tasks
- **Claude 3.5 Haiku** - Simple parsing operations (web summaries, file parsing)

**Optimization opportunity:**
Could use even cheaper models (GPT-3.5-turbo @ $1.50 vs $15 per 1M tokens) for basic bash parsing.

---

## ðŸš€ Performance Optimizations

### 1. **Prompt Caching (The Big One)**

- **90% cost reduction** and **85% latency reduction** for long prompts
- 5-minute TTL that resets with each cache hit
- Place cached content at prompt beginning
- Use cache breakpoints to separate different cacheable sections

**Implementation:**
```
[Cached: System Prompt + Tools + Directory Tree + Git State]
[Cache Breakpoint]
[Dynamic: Conversation History]
```

### 2. **WebFetch Caching**

- 15-minute self-cleaning cache for repeated URL access
- Prevents naive repeated requests
- HTMLâ†’Markdown conversion cached

### 3. **Intelligent Context Management**

**Static context (loaded once, cached):**
- Full directory tree snapshot (non-updating)
- Git repository state (branch, status, recent commits)
- Environment metadata (cwd, platform, date)

**Warning:** Full directory trees can get big - need pruning strategy

**Dynamic context (per-message):**
- Conversation history
- Todo list (loaded fresh each time)
- System reminders

### 4. **Context Compressor (wU2 Module)**

- Prunes chat history while preserving critical tokens
- 92% threshold for retention
- Enables long-running sessions without explosion

---

## ðŸŽ¨ Prompt Engineering Secrets

### 1. **Constraint Hierarchies**

Three tiers of constraints based on severity:

**Critical Safety Constraints** (absolute language):
- "NEVER use git commands with the -i flag"
- For failure modes that completely break UX
- No exceptions, no workarounds

**Deterministic Constraints** (enforced by tools):
- Must Read file before Edit
- Tools throw errors on violation
- Encode best practices in tool design

**Recovery Strategies** (handle predictable failures):
- Pre-commit hook failures â†’ retry with fixes
- Sandbox permission issues â†’ explain and request
- Compile errors â†’ extract info and iterate

**Why this matters:** Each tier reflects real user friction points and debugging scenarios.

### 2. **XML Tags for Structure**

- Claude fine-tuned to pay special attention to XML tags
- Use `<example>`, `<document>`, `<instructions>` to guide output
- **39% improvement in response quality** with XML-structured prompts

### 3. **System Reminders Everywhere**

"Sprinkle system-reminders everywhere" - including:
- System prompts
- User prompts
- Tool calls
- Tool results

**Purpose:** Reduce drift, keep model focused on current context

### 4. **Massive Tool Descriptions**

- System prompt: ~2,600 tokens
- Tool descriptions: **9,200 tokens**
- Each tool has brief description + extensive "how to call it" prompt

**Example pattern:**
```markdown
## Tool: read_file

Brief: Read a file from the filesystem

Detailed Usage:
- ALWAYS use Read for file access, NEVER cat
- Prefer reading specific line ranges for large files
- Check file exists before attempting read
- Remember: this tool can read images/PDFs as visual content
[... 200 more words of context ...]
```

### 5. **Dynamic Behavior Calibration**

Rather than expensive real-time classification:
- Use **regex pattern matching** on user input
- Keywords like "think harder", "ultrathink" trigger budget adjustments
- Practical tradeoff: accuracy vs. compute efficiency

---

## âœ… Task Management Patterns

### 1. **Explicit State Transitions**

Force model to track progress explicitly:
```
pending â†’ in_progress â†’ completed
```

**Rules:**
- Only ONE task in_progress at a time
- Mark completed ONLY when fully successful
- If tests fail, keep as in_progress
- Create new task for blockers, don't mark old as complete

**Why this matters:** Prevents model from prematurely declaring success.

### 2. **Todo Invocation Heuristics**

**Use TodoWrite when:**
- 3+ distinct steps required
- Multiple files/components involved
- User provides task list (numbered, comma-separated)

**Skip TodoWrite when:**
- Single straightforward action
- Trivial task (< 3 steps)
- Purely conversational

**Purpose:** Prevent overhead, focus on meaningful tracking.

### 3. **Todo List as Context Anchor**

- Dynamically loaded fresh each message
- Enables model to track previous progress
- Acts as "memory" across agent iterations

---

## ðŸ› ï¸ Tool Design Patterns

### 1. **Minimal Returns, Separate Processing**

**Pattern:**
```
WebSearch â†’ Return ONLY title + URL (lightweight)
WebFetch â†’ Separate AI call with Haiku to process content
```

**Not:**
```
WebSearch â†’ Return title + URL + snippet + full text + ...
```

**Why:** Keeps tool outputs small, processing happens in dedicated LLM calls.

### 2. **BatchTool for Parallelization**

- Execute multiple tool calls in single request
- Run in parallel when possible
- Massive performance boost for multi-step operations

**Example:**
```bash
# Instead of sequential:
git status
git diff
git log

# Batch in parallel:
BatchTool([git_status, git_diff, git_log])
```

### 3. **MultiEdit for Atomic Changes**

- Multiple edits to same file in atomic operation
- Prevents partial state issues
- All edits succeed or all fail

### 4. **Security Through Validation Layers**

**Every tool invocation:**
1. UI keystroke validation
2. Permission check
3. Parameter validation
4. Domain safety check (for web)
5. Content validation
6. Syscall sandboxing

**6 orthogonal checks** = defense in depth

---

## ðŸ“Š Development Velocity Secrets

### How Anthropic Ships So Fast

**Daily metrics:**
- **60-100 internal releases** per day
- **~5 PRs per engineer** per day (vs 1-2 typical)
- **1 external release** per day

**How they do it:**
- Claude Code builds Claude Code (dogfooding)
- Immediate feedback loops
- Rapid prototyping (20+ todo list prototypes in 2 days)
- Delete code aggressively when models improve

**Impact:**
When Anthropic doubled engineering headcount, PR throughput increased **67%** (normally drops during scaling).

### Tech Stack Choices

**"On distribution" approach** - use what Claude already excels at:
- TypeScript & React (Claude knows these well)
- Ink framework for terminal UI
- Yoga (Meta's constraints-based layout)
- Bun for speed

**Why:** Claude Code can help build itself more effectively.

---

## ðŸ”’ Security Without Sandboxing

**Design Decision:** No virtualization, runs locally on user machines

**Instead:**
- Permission system (grant once, per-session, or permanent)
- Effect constraints via tool restrictions
- Sub-agents with limited tool access
- Validation layers (see above)

**Why:** Simplicity > complexity. Sandboxing adds massive engineering overhead.

---

## ðŸŽ“ Key Lessons for Runix Code

### 1. **Start Minimal, Delete Aggressively**
- Don't over-engineer
- Trust the model to improve
- Remove scaffolding as models get better
- Aim for Claude Code's "90% self-generated" metric

### 2. **Invest in Prompt Caching**
- 90% cost reduction is massive
- Design prompts for cacheability
- Static context first, dynamic last

### 3. **Use Model Stratification**
- Haiku for simple tasks (web summaries, parsing)
- Sonnet for reasoning
- Don't waste money on expensive models for trivial operations

### 4. **System Reminders are Critical**
- Sprinkle everywhere to reduce drift
- Include in tool results, not just prompts
- Keep model focused on current context

### 5. **Batch Operations Aggressively**
- BatchTool is crucial for performance
- Parallel execution when possible
- Massive UX improvement

### 6. **Tool Descriptions > System Prompts**
- 9,200 tokens in tool descriptions vs 2,600 in system prompt
- Each tool teaches model how to use it
- More effective than generic instructions

### 7. **Security Through Layers**
- 6 validation checks per tool
- Constraint hierarchies (critical/deterministic/recovery)
- Defense in depth, not single point

### 8. **Explicit State Management**
- Force model to track progress
- State transitions prevent premature success claims
- Todo list as memory anchor

### 9. **Topic Detection Prevents Drift**
- Dedicated LLM call to classify threads
- Small overhead, huge benefit
- Keeps conversations focused

### 10. **Build What You Use**
- Claude Code builds Claude Code
- Dogfooding reveals real issues
- 60-100 releases/day = tight feedback loop

---

## ðŸš« Anti-Patterns to Avoid

### Don't:
1. **Over-engineer scaffolding** - Models improve faster than code
2. **Skip prompt caching** - 90% cost reduction is too big to ignore
3. **Return verbose tool outputs** - Keep minimal, process separately
4. **Use expensive models for parsing** - Haiku for simple tasks
5. **Single validation layer** - Need defense in depth
6. **Let model declare success** - Force explicit state transitions
7. **Mix static and dynamic context** - Separate for caching
8. **Ignore batch operations** - Massive performance gains available
9. **Build complex sandboxing** - Permission system + effect constraints enough
10. **Write code models can write** - Let Claude Code build itself

---

## ðŸŽ¯ The Secret Sauce (TL;DR)

**What makes Claude Code work:**

1. **Radical simplicity** - Less code, more model capability
2. **Prompt caching** - 90% cost reduction, 85% latency reduction
3. **Model stratification** - Right model for right task
4. **System reminders everywhere** - Prevent drift
5. **Massive tool descriptions** - 9,200 tokens teaching proper usage
6. **Constraint hierarchies** - Critical/deterministic/recovery tiers
7. **Explicit state management** - Force progress tracking
8. **Batch operations** - Parallel execution for performance
9. **Security through layers** - 6 validation checks per tool
10. **Dogfooding at scale** - 60-100 releases/day, Claude builds Claude

**The meta-lesson:** Trust the model. Build minimal scaffolding. Delete code as models improve. The best code is no code.

---

## ðŸ“š Sources

- Kir Shatrov: [Reverse engineering Claude Code](https://kirshatrov.com/posts/claude-code-internals)
- Pierce.dev: [Under the hood of Claude Code](https://pierce.dev/notes/under-the-hood-of-claude-code/)
- Sabrina.dev: [Reverse-Engineering Claude Code](https://www.sabrina.dev/p/reverse-engineering-claude-code-using)
- Pragmatic Engineer: [How Claude Code is built](https://newsletter.pragmaticengineer.com/p/how-claude-code-is-built)
- ShareAI Lab: Full reverse engineering of v1.0.33 (50,000+ lines analyzed)

---

*Last updated: 2025-01-04*
