# Runix Monorepo

This repository serves as the main development container for the Runix ecosystem, including the core library, supporting libraries, and applications built on top of Runix.

> **⚠️ Early Development Notice**: Runix is in active development. APIs and documentation may change as the project evolves.

## What is Runix?

Runix is a **type-safe framework for building LLM-powered applications and agents** where you can actually control what the code can do—even when that code is generated by an LLM.

**The Core Problem It Solves:**

In languages like Python, JavaScript, or C#, any code can execute arbitrary system operations (file access, network calls, system commands) from anywhere. This makes it fundamentally unsafe to run LLM-generated code or give LLMs powerful tool access—you have no way to constrain what they can actually do.

Runix uses Haskell's effect system (Polysemy) and Safe Haskell to provide **compile-time enforced capability constraints**:
- Tasks declare exactly which effects they need: `Members '[FileSystem, LLM model] r => ...`
- If it compiles with a certain type signature, you know it can **only** access those specific capabilities
- LLM-generated code or agent tools can be safely executed because the type system guarantees they can't escape their sandbox
- No runtime checks needed—the compiler proves the code is safe

**Why This Matters:**

This is the only LLM framework (that we know of) where you can:
1. **Run LLM-generated code with trust** - If it compiles with type signature `Members '[FileSystem] r => ...`, it mathematically cannot access network, execute commands, or do anything except read/write files
2. **Build safe agent systems** - Give an LLM agent a tool that can only access specific effects, and the type system guarantees it can't escape that constraint
3. **Compose capabilities safely** - Combine tasks with different permission levels, knowing exactly what each component can do

This is only possible in Haskell—other languages cannot replicate this level of compile-time safety for side effects.

## Repository Structure

This monorepo contains:

- **`runix/`** - The core Runix library
  - A secure, modular framework for running and combining type-safe tasks written in Haskell
  - Built on Polysemy effects for composable, controlled access to system resources (FileSystem, LLM, HTTP, etc.)
  - Safe Haskell enforcement for security
  - Type-safe capability constraints that are enforced at compile time
  - Separate concerns: effects (what operations are available), runners (how tasks execute), and frontends (how users interact)
  - See [runix/README.md](runix/README.md) for comprehensive documentation

- **`libs/universal-llm/`** - Universal LLM library
  - Haskell library for type-safe interactions with various Large Language Models
  - Extracted as separate library because LLM patterns are broadly applicable
  - Provides the LLM effect that Runix effects can use
  - Supports multiple providers (Anthropic, LlamaCpp, etc.)

- **`apps/runix-code/`** - Real-world test application for Runix
  - AI-powered coding assistant and agent loop built using Runix
  - Demonstrates Runix's capability to build a fully-featured application
  - Features: Brick TUI, tool calling, session management, multi-model support
  - This is more than a demo—it's a real application proving Runix's functionality
  - Also includes simple CLI runner for quick testing

- **`apps/`** - Other example applications
  - `chatbot/` - Simple chatbot application
  - `helloworld/` - Minimal example application
  - Most development effort has focused on runix-code

- **`tasks/`** - Example task (dndwiki)
  - Demonstrates task creation and effect usage
  - Shows how to structure Runix tasks

- **`templates/`** - Project templates for creating new Runix tasks and applications

## Getting Started

### Prerequisites

This project uses Nix for reproducible development environments and builds. You'll need:
- Nix with flakes enabled
- Git (for submodules)

### Setting Up the Development Environment

First, clone the repository with its submodules:

```bash
# Clone the repository with submodules
git clone --recurse-submodules <repo-url>

# Or if already cloned, initialize submodules
git submodule update --init --recursive
```

Then enter the development shell provided by `flake.nix`:

```bash
# Enter the development shell
nix develop

# This provides:
# - GHC (Glasgow Haskell Compiler)
# - Cabal 3.14.2.0 (for HLS compatibility)
# - Haskell Language Server
# - Required Haskell libraries (polysemy, aeson, http-conduit, etc.)
# - Hoogle documentation
```

### Building

The cabal project includes all packages defined in `cabal.project`:

```bash
# Build all packages
cabal build all

# Build specific package
cabal build runix
cabal build runix-code

# Run tests
cabal test all
```

### Running Applications

#### runix-code

Runix-code is an AI-powered coding assistant. To run it:

```bash
# Set required environment variable based on your chosen model
# For Claude models:
export ANTHROPIC_OAUTH_TOKEN="your-anthropic-oauth-token"

# Optional: Select model (defaults to claude-sonnet-45)
export RUNIX_MODEL="claude-sonnet-45"  # or "glm-45-air", "qwen3-coder", "openrouter", "glm-45-air-zai", "glm-46-zai"

# For LlamaCpp models (qwen3-coder):
export LLAMACPP_ENDPOINT="http://localhost:8080/v1"  # default if not set

# For OpenRouter:
export OPENROUTER_API_KEY="your-openrouter-api-key"
export OPENROUTER_MODEL="anthropic/claude-3.5-sonnet"  # or any OpenRouter model

# For ZAI models (glm-45-air-zai, glm-46-zai):
export ZAI_API_KEY="your-zai-api-key"
export ZAI_ENDPOINT="https://api.z.ai/api/coding/paas/v4"  # default if not set

# Run the TUI
cabal run runix-code:runix-code-tui

# Or build and run via nix
nix build
./result/bin/runix-code-tui
```

**Environment Variables:**
- `RUNIX_MODEL` - Model selection (default: `"claude-sonnet-45"`):
  - `"claude-sonnet-45"` - Anthropic Claude Sonnet 4.5
  - `"glm-45-air"` - GLM-4.5-Air
  - `"qwen3-coder"` - Qwen3 Coder (via LlamaCpp)
  - `"openrouter"` - Any model via OpenRouter
  - `"glm-45-air-zai"` - GLM-4.5-Air via ZAI
  - `"glm-46-zai"` - GLM-4.6 via ZAI

**Model-specific Environment Variables:**
- `ANTHROPIC_OAUTH_TOKEN` - **Required** for Claude models
- `LLAMACPP_ENDPOINT` - LlamaCpp server endpoint (default: `http://localhost:8080/v1`)
- `OPENROUTER_API_KEY` - **Required** for OpenRouter models
- `OPENROUTER_MODEL` - **Required** for OpenRouter (e.g., `"anthropic/claude-3.5-sonnet"`)
- `ZAI_API_KEY` - **Required** for ZAI models
- `ZAI_ENDPOINT` - ZAI endpoint (default: `https://api.z.ai/api/coding/paas/v4`)

## Project Status

This is the primary development repository containing the Runix framework and real-world applications built with it.

### Current State

- **Runix library**: Active development, core functionality stable
- **Universal-LLM library**: Active development, core functionality stable
- **runix-code application**: Active development, beyond-demo stage with real features
- **Other applications**: Early stage, more experimental
- **Documentation**: In progress, may be incomplete or inconsistent

### Development Philosophy

The project emphasizes:
- **Type safety**: Extensive use of Haskell's type system
- **Security**: Safe Haskell and controlled effects
- **Modularity**: Composable tasks and effects
- **Reproducibility**: Nix-based builds and dependency management

## Documentation

- **Runix Core**: See [runix/README.md](runix/README.md) for detailed documentation on the framework, task development, and effect system
- **Task Creation**: See [runix/howto-create-tasks-with-ai.md](runix/howto-create-tasks-with-ai.md)
- **Agentic Design**: See [agentic-runix.md](agentic-runix.md)

## Contributing

Contributions are welcome, including major refactors that improve the architecture. The codebase prioritizes:
- Clear, elegant solutions over quick workarounds
- Well-understood tradeoffs when compromises are necessary
- Type-safe, composable designs

**Note on contribution scope**: If your contribution primarily adds models or handles special cases, consider packaging it as a separate library. We're keeping the core minimal to facilitate architectural evolution.

**Contributor License Agreement**: By contributing, you agree that your code may be relicensed to a different OSI-approved open source license in the future.

## License

- **Libraries** (`runix/`, `libs/universal-llm/`): Apache License 2.0
- **Applications** (`apps/runix-code/`): GNU General Public License

See individual LICENSE files in each directory for full license text.

## Issues and Feedback

This project is in early development, and we're focused on core architecture rather than small details. That said:

- **Feedback is welcome** - Let us know what works and what doesn't
- **Bug fix PRs are welcome** - Straightforward fixes without intrusive changes are appreciated
- **Architectural improvements are welcome** - Well-designed refactors that solve architectural issues are encouraged, but they should address fundamental problems, not just fix single small issues

Please understand that during this phase, minor issues may not be prioritized as we focus on getting the architecture right.
