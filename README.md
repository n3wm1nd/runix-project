# Runix

**Type-safe framework for building LLM-powered applications and agents with compile-time enforced capability constraints.**

> **⚠️ Early Development Notice**: Runix is in active development. APIs and documentation may change as the project evolves.

## What is Runix?

Runix lets you build LLM-powered applications where you can **actually control what the code can do**—even when that code is generated by an LLM. It uses Haskell's effect system to provide compile-time enforced capability constraints.

**The Problem:**

```python
# Python: Can this function access the network? Read files? Execute commands?
# You have no way to know without reading every line of code.
def process_data(input):
    # Could do literally anything
    ...
```

**The Runix Solution:**

```haskell
-- If this compiles, it is TYPE-SYSTEM GUARANTEED to only perform FileSystem operations
processData :: Members '[FileSystem] r => Input -> Sem r Output
processData input = do
    content <- readFile "data.txt"
    writeFile "output.txt" (transform content)
    -- Trying to make network calls or execute commands won't even compile
```

Tasks declare exactly which effects they need. The type signature isn't just documentation—it's a **compile-time proof** that the code can only access those specific capabilities:

- `Members '[FileSystem] r => ...` - Can ONLY read/write files
- `Members '[FileSystem, HTTP] r => ...` - Can access files and network
- `Members '[LLM model] r => ...` - Can ONLY call the LLM, nothing else

This means:
1. **LLM-generated code is safe to run** - If it compiles with restricted effects, it cannot escape its sandbox
2. **Agent tools have guaranteed constraints** - The type system proves what each tool can and cannot do
3. **No runtime checks needed** - The compiler verifies safety before any code executes

## Why Haskell? (Why not Python/JavaScript/C#?)

This level of safety is **only possible in Haskell**. Here's why:

**In Python, JavaScript, C#, Java, etc.:**
- Any code can perform IO operations from anywhere
- Runtime sandboxing can be bypassed (imports, eval, reflection, etc.)
- You cannot prove at compile-time that code won't access certain resources
- Even static analysis can't account for dynamic features

**In Haskell:**
- Effects are part of the type system
- Safe Haskell prevents unsafe escape hatches
- If code compiles with type `Members '[FileSystem] r => ...`, the type system **guarantees** it cannot access network, execute commands, or do anything beyond file operations
- The compiler itself enforces the constraints—no runtime sandboxing needed

This makes Runix the only LLM framework (that we know of) where you can run LLM-generated code and agent tools with compiler-verified safety guarantees.

## What's in this Monorepo?

This repository contains the complete Runix ecosystem:

**Core Libraries:**
- **`runix/`** - The core framework providing the effect system, task execution model, and Safe Haskell enforcement. [Documentation →](runix/README.md)
- **`libs/universal-llm/`** - Type-safe LLM interaction library supporting multiple providers (Anthropic, LlamaCpp, OpenRouter, etc.). Provides the LLM effect used by Runix.

**Applications:**
- **`apps/runix-code/`** - AI-powered coding assistant demonstrating Runix's capabilities. A real, fully-featured application with TUI, tool calling, session management, and multi-model support.
- **`apps/`** - Additional example applications (chatbot, helloworld)

**Other:**
- **`tasks/`** - Example tasks demonstrating task creation and effect usage
- **`templates/`** - Project templates for creating new Runix tasks and applications

## Quick Start

### Prerequisites

- Nix with flakes enabled
- Git

### Get Running in 3 Steps

**1. Clone and setup:**
```bash
git clone --recurse-submodules <repo-url>
cd runix
nix develop
```

**2. Build everything:**
```bash
cabal build all
```

**3. Run runix-code (the coding assistant):**
```bash
# Set your API token (for Claude models)
export ANTHROPIC_OAUTH_TOKEN="your-token-here"

# Run it
cabal run runix-code:runix-code-tui
```

That's it! You should see the runix-code TUI interface.

### Using Different Models

By default, runix-code uses Claude Sonnet 4.5. To use other models:

```bash
# Use a different model
export RUNIX_MODEL="qwen3-coder"  # or "glm-45-air", "openrouter", etc.

# Model-specific configuration:
# For LlamaCpp (qwen3-coder):
export LLAMACPP_ENDPOINT="http://localhost:8080/v1"

# For OpenRouter:
export OPENROUTER_API_KEY="your-key"
export OPENROUTER_MODEL="anthropic/claude-3.5-sonnet"

# For ZAI models:
export ZAI_API_KEY="your-key"
```

Available models: `claude-sonnet-45` (default), `qwen3-coder`, `glm-45-air`, `openrouter`, `glm-45-air-zai`, `glm-46-zai`

## About runix-code

Runix-code is more than a demo—it's a real AI coding assistant built entirely on Runix, proving the framework's ability to build production-ready applications.

**Why it matters:**
- **Demonstrates Runix in practice** - Shows how to build complex LLM applications with the effect system
- **Real-world testing ground** - Surfaces architectural issues and drives framework improvements
- **Usable tool** - Actually useful for development work, not just a proof of concept

**Features:**
- Terminal UI (Brick-based TUI)
- Tool calling with type-safe effect constraints
- Session management and hot-reload
- Multi-model support
- Streaming responses
- Compatible with Claude Code's CLAUDE.md instructions, subagents, and skills
- Simple, straightforward agent loop (~80 lines) and minimal tool set
- Easily adaptable for project-specific builds

This is the "killer app" demonstrating what's possible with compile-time verified LLM agent safety. The architecture is intentionally simple—the agent loop and tool system are straightforward enough to customize for your own projects.

## Development

### Building Specific Packages

```bash
cabal build runix              # Core library
cabal build universal-llm       # LLM library
cabal build runix-code          # The coding assistant
```

### Running Tests

```bash
cabal test all
```

### Development Environment

The `nix develop` shell provides:
- GHC (Glasgow Haskell Compiler)
- Cabal 3.14.2.0 (for HLS compatibility)
- Haskell Language Server
- All required Haskell libraries
- Hoogle documentation

## Project Status

**Current State:**
- **Runix library**: Active development, core functionality stable
- **Universal-LLM library**: Active development, core functionality stable
- **runix-code**: Active development, beyond-demo stage with real features
- **Documentation**: In progress, may be incomplete

**Development Philosophy:**
- **Type safety** - Extensive use of Haskell's type system
- **Security** - Safe Haskell and controlled effects
- **Modularity** - Composable tasks and effects
- **Reproducibility** - Nix-based builds and dependency management

## Documentation

- **Runix Core**: [runix/README.md](runix/README.md) - Framework documentation, task development, effect system
- **Task Creation**: [runix/howto-create-tasks-with-ai.md](runix/howto-create-tasks-with-ai.md)
- **Agentic Design**: [agentic-runix.md](agentic-runix.md)

## Contributing

Contributions are welcome, including major refactors that improve the architecture. The codebase prioritizes:
- Clear, elegant solutions over quick workarounds
- Well-understood tradeoffs when compromises are necessary
- Type-safe, composable designs

**Note on contribution scope**: If your contribution primarily adds models or handles special cases, consider packaging it as a separate library. We're keeping the core minimal to facilitate architectural evolution.

**Contributor License Agreement**: By contributing, you agree that your code may be relicensed to a different OSI-approved open source license in the future.

## License

- **Libraries** (`runix/`, `libs/universal-llm/`): Apache License 2.0
- **Applications** (`apps/runix-code/`): GNU General Public License

See individual LICENSE files in each directory for full license text.

## Issues and Feedback

This project is in early development, and we're focused on core architecture rather than small details. That said:

- **Feedback is welcome** - Let us know what works and what doesn't
- **Bug fix PRs are welcome** - Straightforward fixes without intrusive changes are appreciated
- **Architectural improvements are welcome** - Well-designed refactors that solve architectural issues are encouraged, but they should address fundamental problems, not just fix single small issues

Please understand that during this phase, minor issues may not be prioritized as we focus on getting the architecture right.
